

## Tech Stack
- Java
- HTML
- CSS
- JavaScript

## Daily Log

### Day 1
- Cleaned HTML structure
- Improved spacing and layout
- Added mobile responsiveness
- Polished UI with hover effects# 100-days-of-code
My 100 Days of Code challenge (Java, HTML, CSS, JavaScript)


### Day 2
- Practiced JavaScript DOM events
- Used addEventListener for click and hover
- Implemented dark mode using document.body
- Debugged event handling issues


### Day 3
- Learned Java threads
- Practiced start() vs run()
- Ran multiple threads concurrently
- Used thread names to observe execution


### Day 4
- Built a login form
- Implemented JavaScript form validation
- Used querySelectorAll for multiple error elements
- Debugged DOM selection issues


### Day 5
- Built a theme switcher
- Used DOM manipulation for UI changes
- Persisted user preferences using localStorage
- Restored state on page reload


### Day 6
- Learned what threads are
- Compared Thread vs Runnable
- Practiced concurrent execution
- Understood why Runnable is preferred


### Day 7
- Studied thread lifecycle
- Used sleep() to pause execution
- Used join() for thread coordination
- Observed thread state transitions


### Day 8
- Learned about race conditions
- Understood thread safety issues
- Used synchronized methods and blocks
- Fixed data inconsistency in multithreaded code


### Day 9
- Simulated multiple users logging into an app
- Used thread pool to handle user requests safely
- Understood how backend manages concurrent users


### Day 10
- Learned how to run background tasks without blocking the app
- Used Callable to return results from threads
- Used Future to receive login status


### Day 11
- Connected frontend user actions to backend processing
- Learned how multiple user actions are handled safely
- Used thread pool to prevent system overload


## Day 12 â€“ Java Synchronization

**Goal:**  
Understand how Java handles multiple threads accessing shared data.

**What I learned:**  
- How threads can cause data inconsistency
- How `synchronized` ensures only one thread accesses a method at a time
- Why synchronization is important in real-world applications like banking systems

**Key takeaway:**  
`synchronized` prevents multiple threads from modifying shared data at the same time.
